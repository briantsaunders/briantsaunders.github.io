[{"content":"Since I\u0026rsquo;m using Apple Silicon as my daily driver I haven\u0026rsquo;t been able to use vagrant / virtualbox locally (virtualbox isn\u0026rsquo;t supported on Apple Silicon and it does not look like there are any plans to add support but there are some potential alternatives in the works - Tart and UTM). I use packer for building custom vagrant boxes that I need for development of custom applications.\nSince I can\u0026rsquo;t run this setup locally I do it on a host that has as a bare metal install of Ubuntu (virtualbox can\u0026rsquo;t be installed within a VM). Because it\u0026rsquo;s running remotely I need to set the headless variable to true. When running locally virtualbox would automatically pop up the console window so you could follow along on the progress but when running in headless mode this isn\u0026rsquo;t an option. This console window can be handy when you\u0026rsquo;re initially developing your packer configuration files.\nHave no fear! There is still a way to get console access when running packer / vagrant / virtualbox remotely and headless. If you have ever watched the packer log file as it\u0026rsquo;s running you may have noticed the following:\n==\u0026gt; virtualbox-iso.base: Starting the virtual machine... virtualbox-iso.base: The VM will be run headless, without a GUI. If you want to virtualbox-iso.base: view the screen of the VM, connect via VRDP without a password to virtualbox-iso.base: rdp://127.0.0.1:5911 If you were to try to connect without modifying your packer config you would get connection refused. But if you add the following line to your packer config it will work:\nvboxmanage = [ [ \u0026#34;modifyvm\u0026#34;, \u0026#34;{{.Name}}\u0026#34;, \u0026#34;--vrdeaddress\u0026#34;, \u0026#34;0.0.0.0\u0026#34; ] ] The packer log will still look the exact same as it previously showed rdp://127.0.0.1:5911 but it will work if you attempt to connect remotely (it may prompt for a password but just leave blank and continue). Once I know my packer config is in a good place I will remove this config item.\n","permalink":"https://briantsaunders.github.io/posts/2023/01/configuring-headless-packer-virtualbox-console-access/","summary":"Since I\u0026rsquo;m using Apple Silicon as my daily driver I haven\u0026rsquo;t been able to use vagrant / virtualbox locally (virtualbox isn\u0026rsquo;t supported on Apple Silicon and it does not look like there are any plans to add support but there are some potential alternatives in the works - Tart and UTM). I use packer for building custom vagrant boxes that I need for development of custom applications.\nSince I can\u0026rsquo;t run this setup locally I do it on a host that has as a bare metal install of Ubuntu (virtualbox can\u0026rsquo;t be installed within a VM).","title":"Configuring Headless Packer Virtualbox Console Access"},{"content":"I\u0026rsquo;ve been working with vagrant boxes for quite awhile now. I usually use them for development environments or creating lab environments for testing various network functions (i.e. BGP EVPN). Often times when I\u0026rsquo;m using a vagrant box I need to get it in a certain state before it\u0026rsquo;s ready for me to begin using. In the situation of creating lab environments I may need to install FRRouting on the vagrant box and then apply a configuration. A handy feature that vagrant provides to make this possible is the ability to use provisioners that can execute a script prior to the vagrant box being ready for use. The ones I find myself using most are the shell provisioner and ansible local provisioner. In this post I\u0026rsquo;ll go over how I use the ansible local provisioner to install FRRouting on a Ubuntu 20.04 vagrant box. If you would like to follow along I have created an example located in github here.\nPrerequisites Before you begin you need to do the following:\nInstall Vagrant on your workstation Install a Vagrant Provider on your workstation Review the Vagrantfile Whenever you are working with vagrant boxes you are going to have a Vagrantfile defined. Check out the documentation provided in the previous statement to learn more about Vagrantfiles and everything you can do within one. In this post I won\u0026rsquo;t go into much detail on the Vagrantfile aside from the provisioner section. The basic gist of a Vagrantfile is it essentially defines your vagrant environment - the virtual boxes, their network connectivity, resources, etc.\nLooking at the Vagrantfile in our example github repo you\u0026rsquo;ll see that it\u0026rsquo;s pretty simple.\nVagrant.configure(\u0026#34;2\u0026#34;) do |config| config.vm.box = \u0026#34;bento/ubuntu-20.04\u0026#34; config.vm.provision \u0026#34;ansible_local\u0026#34; do |ansible| ansible.playbook = \u0026#34;playbook.yml\u0026#34; ansible.install_mode = \u0026#34;pip\u0026#34; ansible.pip_install_cmd = \u0026#34;sudo apt install -y python3-distutils \u0026amp;\u0026amp; curl https://bootstrap.pypa.io/get-pip.py | sudo python3\u0026#34; ansible.galaxy_command = \u0026#34;sudo ansible-galaxy install -r /vagrant/collections/requirements.yml\u0026#34; end end The config.vm.box statement defines the vagrant box that we\u0026rsquo;re going to use (bento/ubuntu-20.04). The next statement goes into our ansible local provisioner. When you perform a vagrant up vagrant will first bring the vagrant box online. Once the vagrant box is online it will run the provisioner. The ansible local provisioner will first install ansible on the vagrant box. There\u0026rsquo;s a couple methods you can use for the installation. The default method is installing via the operating system package manager. On Ubuntu 20.04 I had issues using that method as focal was not recognized as a valid option. This is the error that I received when attempting that install method:\nE: The repository \u0026#39;http://ppa.launchpad.net/ansible/ansible/ubuntu focal Release\u0026#39; does not have a Release file. Another approach that vagrant allows is installation via pip. Prior to installing ansible via pip I must first install pip. The vagrant box that I selected comes bare bones and pip is not available. Ubuntu 20.04 does not come with disutils and the pip installation will fail if it\u0026rsquo;s not present. So I also needed to make sure that is installed prior to the pip installation. Within the Vagrantfile you define how pip should be installed via the pip_install_command statement. In the above example you can see I\u0026rsquo;m installing python3-disutils first and then installing pip.\nOnce pip is installed vagrant will proceed with installing ansible. If you prefer a specific version of ansible you can define the version otherwise pip will install the latest available. If you have any ansible roles or collections that need to be installed prior to your playbook executing you can define those in the galaxy_command statement. In my example I have a requirements.yml file defined within my collections folder that needs to be installed prior to my playbook executing.\nAfter ansible is installed vagrant will then run the playbook that is defined. In my example my playbook is called playbook.yml. My playbook basically follows the steps outlined here for installing FRRouting. After the installation I also edit the sysctl.conf file to enable routing on the vagrant box. Here are the contents of my playbook:\n--- - name: provision vagrant box with frrouting hosts: all gather_facts: no tasks: - name: add frr apt-key ansible.builtin.apt_key: url: https://deb.frrouting.org/frr/keys.asc state: present become: yes - name: get host distribution ansible.builtin.command: lsb_release -sc register: release - name: add frr repository into source list ansible.builtin.apt_repository: repo: \u0026#34;deb https://deb.frrouting.org/frr {{ release.stdout }} {{ frr_version }}\u0026#34; state: present filename: /etc/apt/sources.list.d/frr vars: frr_version: frr-stable become: yes - name: install frr ansible.builtin.apt: name: - frr - frr-pythontools update_cache: yes register: apt_status retries: 100 until: apt_status is success or (\u0026#39;Failed to lock apt for exclusive operation\u0026#39; not in apt_status.msg and \u0026#39;/var/lib/dpkg/lock\u0026#39; not in apt_status.msg) become: yes - name: edit sysctl.conf for ipv4 forward ansible.posix.sysctl: name: net.ipv4.ip_forward value: \u0026#39;1\u0026#39; state: present reload: yes become: yes - name: edit sysctl.conf for ipv6 forward ansible.posix.sysctl: name: net.ipv6.conf.all.forwarding value: \u0026#39;1\u0026#39; state: present reload: yes become: yes Vagrant Up Go ahead and issue a vagrant up within the example repo. You should see output similar to the following.\nBringing machine \u0026#39;default\u0026#39; up with \u0026#39;virtualbox\u0026#39; provider... ==\u0026gt; default: Importing base box \u0026#39;bento/ubuntu-20.04\u0026#39;... ==\u0026gt; default: Matching MAC address for NAT networking... ==\u0026gt; default: Checking if box \u0026#39;bento/ubuntu-20.04\u0026#39; version \u0026#39;202010.24.0\u0026#39; is up to date... ==\u0026gt; default: Setting the name of the VM: vagrant-box-ansible-provisioner-example_default_1612559846779_78606 ==\u0026gt; default: Fixed port collision for 22 =\u0026gt; 2222. Now on port 2201. ==\u0026gt; default: Clearing any previously set network interfaces... ==\u0026gt; default: Preparing network interfaces based on configuration... default: Adapter 1: nat ==\u0026gt; default: Forwarding ports... default: 22 (guest) =\u0026gt; 2201 (host) (adapter 1) ==\u0026gt; default: Booting VM... ==\u0026gt; default: Waiting for machine to boot. This may take a few minutes... default: SSH address: 127.0.0.1:2201 default: SSH username: vagrant default: SSH auth method: private key default: Warning: Connection reset. Retrying... default: default: Vagrant insecure key detected. Vagrant will automatically replace default: this with a newly generated keypair for better security. default: default: Inserting generated public key within guest... default: Removing insecure key from the guest if it\u0026#39;s present... default: Key inserted! Disconnecting and reconnecting using new SSH key... ==\u0026gt; default: Machine booted and ready! ==\u0026gt; default: Checking for guest additions in VM... default: The guest additions on this VM do not match the installed version of default: VirtualBox! In most cases this is fine, but in rare cases it can default: prevent things such as shared folders from working properly. If you see default: shared folder errors, please make sure the guest additions within the default: virtual machine match the version of VirtualBox you have installed on default: your host and reload your VM. default: default: Guest Additions Version: 6.1.16 default: VirtualBox Version: 6.0 ==\u0026gt; default: Mounting shared folders... default: /vagrant =\u0026gt; /Users/username/directory/vagrant-box-ansible-provisioner-example ==\u0026gt; default: Running provisioner: ansible_local... default: Installing Ansible... default: Installing pip... (for Ansible installation) default: Running ansible-playbook... PLAY [provision vagrant box with frrouting] ************************************ TASK [add frr apt-key] ********************************************************* [DEPRECATION WARNING]: Distribution Ubuntu 20.04 on host default should use /usr/bin/python3, but is using /usr/bin/python for backward compatibility with prior Ansible releases. A future Ansible release will default to using the discovered platform python for this host. See https://docs.ansible.com/ansible/ 2.10/reference_appendices/interpreter_discovery.html for more information. This feature will be removed in version 2.12. Deprecation warnings can be disabled by setting deprecation_warnings=False in ansible.cfg. changed: [default] TASK [get host distribution] *************************************************** changed: [default] TASK [add frr repository into source list] ************************************* changed: [default] TASK [install frr] ************************************************************* changed: [default] TASK [edit sysctl.conf for ipv4 forward] *************************************** changed: [default] TASK [edit sysctl.conf for ipv6 forward] *************************************** changed: [default] PLAY RECAP ********************************************************************* default : ok=6 changed=6 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 You now have a vagrant box that has FRRouting installed!\n","permalink":"https://briantsaunders.github.io/posts/2021/02/working-with-the-ansible-local-provisioner-for-vagrant-boxes/","summary":"I\u0026rsquo;ve been working with vagrant boxes for quite awhile now. I usually use them for development environments or creating lab environments for testing various network functions (i.e. BGP EVPN). Often times when I\u0026rsquo;m using a vagrant box I need to get it in a certain state before it\u0026rsquo;s ready for me to begin using. In the situation of creating lab environments I may need to install FRRouting on the vagrant box and then apply a configuration.","title":"Working with the Ansible Local Provisioner for Vagrant Boxes"},{"content":"Typically when deploying python API\u0026rsquo;s I go with Flask. Over the years I\u0026rsquo;ve tried out a few python web frameworks but continually find myself coming back to Flask. It\u0026rsquo;s hard not to like with it\u0026rsquo;s simple setup and great documentation. Plus there\u0026rsquo;s plenty of examples out there on the internet on how to deploy Flask and use it for a variety of scenarios.\nIt\u0026rsquo;s considered a micro framework, so it comes with the bare bones to make a web framework run but leaves you the flexibility to pick and choose the libraries to add on that make the most sense for your app. When developing REST API\u0026rsquo;s I like using marshmallow, webargs, and apispec.\nI recently came across flask-apispec that bundles all these libraries together and bolts onto the Flask framework. It has now become my go to when developing in Flask. Instead of having to account for marshmallow, webargs, and apispec seperately it neatly integrates all three into Flask and creates a cleaner experience. Plus because of the integrations it makes creating an open api specification easier and handles creation of the swagger documentation for you.\nExample EXAMPLE GITHUB REPO\nI\u0026rsquo;m a visual learner so it\u0026rsquo;s helpful for me to see an example while also reading about it so I created a simple API demonstrating my setup. This example is meant to run in linux and the API allows you to GET, POST, and DELETE VRFs within linux. Included in the repo is a Vagrant file that will allow you to run the app on your machine. Check out the repo for instructions on getting it up and running with vagrant.\n","permalink":"https://briantsaunders.github.io/posts/2019/08/my-flask-api-setup/","summary":"Typically when deploying python API\u0026rsquo;s I go with Flask. Over the years I\u0026rsquo;ve tried out a few python web frameworks but continually find myself coming back to Flask. It\u0026rsquo;s hard not to like with it\u0026rsquo;s simple setup and great documentation. Plus there\u0026rsquo;s plenty of examples out there on the internet on how to deploy Flask and use it for a variety of scenarios.\nIt\u0026rsquo;s considered a micro framework, so it comes with the bare bones to make a web framework run but leaves you the flexibility to pick and choose the libraries to add on that make the most sense for your app.","title":"My Flask API Setup"},{"content":"In this post I\u0026rsquo;m going to talk about how to create, edit, and delete VRFs in linux with python. To follow along I have created a vagrant environment and example python script in github.\nHere\u0026rsquo;s our environment:\nPrior to us creating the VRFs all servers connected to site1router will be able to talk to each other. In this post we will create two VRFs, vrf1 and vrf2. On site1router we will then associate interfaces eth1 and eth2 with vrf1 and interfaces eth3 and eth4 with vrf2. Once the interface is associated with the vrf the network configured on the interface will be contained to their respective vrf route table. This will prevent servers on seperate VRFs from being able to communicate.\nPrerequisites If you\u0026rsquo;re following along via the vagrant environment these are handled for you but if you\u0026rsquo;re wanting to perform this on your own you need to ensure that the following prerequisites are met.\nOn the linux host that the VRFs will be created on you need to make sure the following is installed:\npyroute2 Pyroute2 is the python package that is going to allow for the management of VRFs. It\u0026rsquo;s very useful for interacting with the linux network stack with python.\nOn the same linux host you need to ensure that you have enabled ipv4 forwarding so that it can route packets. From the CLI you can enable via:\nsudo sysctl -w net.ipv4.ip_forward=1 VRFs CLI Commands Before we show how to set this up within python lets review the CLI commands that you would enter if you wanted to manually configure. We\u0026rsquo;re going to be using our vagrant environment as the example for the commands to use.\nCreate VRFs sudo ip link add vrf1 type vrf table 1 sudo ip link set dev vrf1 up sudo ip link add vrf2 type vrf table 2 sudo ip link set dev vrf2 up Associate Interfaces with VRF sudo ip link set dev eth1 master vrf1 sudo ip link set dev eth2 master vrf1 sudo ip link set dev eth3 master vrf2 sudo ip link set dev eth4 master vrf2 Remove Interfaces from VRF sudo ip link set dev eth1 nomaster sudo ip link set dev eth2 nomaster sudo ip link set dev eth3 nomaster sudo ip link set dev eth4 nomaster Delete VRFs sudo ip link delete vrf1 sudo ip link delete vrf2 VRFs in Python Validate Pre Configuration Prior to creating our VRFs and associating the interfaces let\u0026rsquo;s confirm one of our servers can talk to all the others via a simple ping.\nλ vagrant ssh site1server1 Last login: Sun May 26 07:34:55 2019 from 10.0.2.2 vagrant@site1server1:~$ ping 10.1.2.10 PING 10.1.2.10 (10.1.2.10) 56(84) bytes of data. 64 bytes from 10.1.2.10: icmp_seq=1 ttl=63 time=1.11 ms 64 bytes from 10.1.2.10: icmp_seq=2 ttl=63 time=0.570 ms ^C --- 10.1.2.10 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 0.570/0.840/1.111/0.272 ms vagrant@site1server1:~$ ping 10.1.3.10 PING 10.1.3.10 (10.1.3.10) 56(84) bytes of data. 64 bytes from 10.1.3.10: icmp_seq=1 ttl=63 time=0.960 ms 64 bytes from 10.1.3.10: icmp_seq=2 ttl=63 time=2.02 ms 64 bytes from 10.1.3.10: icmp_seq=3 ttl=63 time=1.80 ms ^C --- 10.1.3.10 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2004ms rtt min/avg/max/mdev = 0.960/1.596/2.026/0.460 ms vagrant@site1server1:~$ ping 10.1.4.10 PING 10.1.4.10 (10.1.4.10) 56(84) bytes of data. 64 bytes from 10.1.4.10: icmp_seq=1 ttl=63 time=72.3 ms 64 bytes from 10.1.4.10: icmp_seq=2 ttl=63 time=1.93 ms 64 bytes from 10.1.4.10: icmp_seq=3 ttl=63 time=1.92 ms ^C --- 10.1.4.10 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2004ms rtt min/avg/max/mdev = 1.929/25.414/72.377/33.207 ms vagrant@site1server1:~$ Create VRFs from pyroute2 import IPDB with IPDB() as ipdb: with ipdb.create(kind=\u0026#34;vrf\u0026#34;, ifname=\u0026#34;vrf1\u0026#34;, vrf_table=1) as vrf: vrf.up() with ipdb.create(kind=\u0026#34;vrf\u0026#34;, ifname=\u0026#34;vrf2\u0026#34;,vrf_table=2) as vrf: vrf.up() Associate Interfaces with VRF from pyroute2 import IPDB with IPDB() as ipdb: with ipdb.interfaces[\u0026#34;vrf1\u0026#34;] as vrf: vrf.add_port(ipdb.interfaces[\u0026#34;eth1\u0026#34;].index) vrf.add_port(ipdb.interfaces[\u0026#34;eth2\u0026#34;].index) with ipdb.interfaces[\u0026#34;vrf2\u0026#34;] as vrf: vrf.add_port(ipdb.interfaces[\u0026#34;eth3\u0026#34;].index) vrf.add_port(ipdb.interfaces[\u0026#34;eth4\u0026#34;].index) Validate Post Configuration After creating our VRFs and associating out interfaces to their respective VRF let\u0026rsquo;s confirm the site1router route table is updated to reflect the VRFs and that the servers can only communicate with other hosts associated with the same VRF.\nList site1router vrfs.\nvagrant@site1router:~$ ip link show type vrf 7: vrf1: \u0026lt;MASTER,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UP mode DEFAULT group default qlen 1000 link/ether 62:ec:0e:17:e6:69 brd ff:ff:ff:ff:ff:ff 8: vrf2: \u0026lt;MASTER,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UP mode DEFAULT group default qlen 1000 link/ether 46:44:1f:75:a1:cb brd ff:ff:ff:ff:ff:ff vagrant@site1router:~$ Check site1router global route table.\nvagrant@site1router:~$ route Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface default _gateway 0.0.0.0 UG 100 0 0 eth0 10.0.2.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0 _gateway 0.0.0.0 255.255.255.255 UH 100 0 0 eth0 vagrant@site1router:~$ Check site1router vrf1 and vrf2 route table.\nvagrant@site1router:~$ ip route show vrf vrf1 10.1.1.0/24 dev eth1 proto kernel scope link src 10.1.1.1 10.1.2.0/24 dev eth2 proto kernel scope link src 10.1.2.1 vagrant@site1router:~$ ip route show vrf vrf2 10.1.3.0/24 dev eth3 proto kernel scope link src 10.1.3.1 10.1.4.0/24 dev eth4 proto kernel scope link src 10.1.4.1 vagrant@site1router:~$ Confirm site1server1 can only talk to site1server2.\nvagrant@site1server1:~$ ping 10.1.2.10 PING 10.1.2.10 (10.1.2.10) 56(84) bytes of data. 64 bytes from 10.1.2.10: icmp_seq=1 ttl=63 time=1.49 ms 64 bytes from 10.1.2.10: icmp_seq=2 ttl=63 time=1.52 ms ^C --- 10.1.2.10 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 1.492/1.507/1.523/0.041 ms vagrant@site1server1:~$ ping 10.1.3.10 PING 10.1.3.10 (10.1.3.10) 56(84) bytes of data. ^C --- 10.1.3.10 ping statistics --- 3 packets transmitted, 0 received, 100% packet loss, time 2028ms vagrant@site1server1:~$ ping 10.1.4.10 PING 10.1.4.10 (10.1.4.10) 56(84) bytes of data. ^C --- 10.1.4.10 ping statistics --- 4 packets transmitted, 0 received, 100% packet loss, time 3070ms vagrant@site1server1:~$ Confirm site1server3 can only talk to site1server3.\nvagrant@site1server3:~$ ping 10.1.4.10 PING 10.1.4.10 (10.1.4.10) 56(84) bytes of data. 64 bytes from 10.1.4.10: icmp_seq=1 ttl=63 time=1.14 ms 64 bytes from 10.1.4.10: icmp_seq=2 ttl=63 time=1.95 ms 64 bytes from 10.1.4.10: icmp_seq=3 ttl=63 time=1.65 ms ^C --- 10.1.4.10 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2005ms rtt min/avg/max/mdev = 1.149/1.588/1.959/0.337 ms vagrant@site1server3:~$ ping 10.1.1.10 PING 10.1.1.10 (10.1.1.10) 56(84) bytes of data. ^C --- 10.1.1.10 ping statistics --- 3 packets transmitted, 0 received, 100% packet loss, time 2035ms vagrant@site1server3:~$ ping 10.1.2.10 PING 10.1.2.10 (10.1.2.10) 56(84) bytes of data. ^C --- 10.1.2.10 ping statistics --- 3 packets transmitted, 0 received, 100% packet loss, time 2051ms vagrant@site1server3:~$ Remove Interfaces from VRF At this time I have not found a way to remove an interface from a vrf via pyroute2. A work around for now is just issuing the shell commands in python.\nimport subprocess subprocess.run(f\u0026#34;ip link set dev eth1 nomaster\u0026#34;, shell=True) subprocess.run(f\u0026#34;ip link set dev eth2 nomaster\u0026#34;, shell=True) subprocess.run(f\u0026#34;ip link set dev eth3 nomaster\u0026#34;, shell=True) subprocess.run(f\u0026#34;ip link set dev eth4 nomaster\u0026#34;, shell=True) Delete VRFs from pyroute2 import IPDB with IPDB() as ipdb: with ipdb.interfaces[\u0026#34;vrf1\u0026#34;] as vrf: vrf.remove() with ipdb.interfaces[\u0026#34;vrf2\u0026#34;] as vrf: vrf.remove() Validate Post Deletion After removing our interfaces from the VRFs and deleting the VRFs lets confirm the global route table is updated on site1router to reflect this change and confirm the servers can now communicate with each other.\nList site1router vrfs.\nvagrant@site1router:~$ ip link show type vrf vagrant@site1router:~$ Check site1router global route table.\nvagrant@site1router:~$ route Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface default _gateway 0.0.0.0 UG 100 0 0 eth0 10.0.2.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0 _gateway 0.0.0.0 255.255.255.255 UH 100 0 0 eth0 10.1.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth1 10.1.2.0 0.0.0.0 255.255.255.0 U 0 0 0 eth2 10.1.3.0 0.0.0.0 255.255.255.0 U 0 0 0 eth3 10.1.4.0 0.0.0.0 255.255.255.0 U 0 0 0 eth4 vagrant@site1router:~$ Confirm site1server1 can talk to all hosts.\nvagrant@site1server1:~$ ping 10.1.2.10 PING 10.1.2.10 (10.1.2.10) 56(84) bytes of data. 64 bytes from 10.1.2.10: icmp_seq=1 ttl=63 time=1.09 ms 64 bytes from 10.1.2.10: icmp_seq=2 ttl=63 time=1.80 ms 64 bytes from 10.1.2.10: icmp_seq=3 ttl=63 time=1.62 ms ^C --- 10.1.2.10 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2004ms rtt min/avg/max/mdev = 1.090/1.507/1.807/0.305 ms vagrant@site1server1:~$ ping 10.1.3.10 PING 10.1.3.10 (10.1.3.10) 56(84) bytes of data. 64 bytes from 10.1.3.10: icmp_seq=1 ttl=63 time=0.996 ms 64 bytes from 10.1.3.10: icmp_seq=2 ttl=63 time=0.978 ms 64 bytes from 10.1.3.10: icmp_seq=3 ttl=63 time=0.699 ms ^C --- 10.1.3.10 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2003ms rtt min/avg/max/mdev = 0.699/0.891/0.996/0.135 ms vagrant@site1server1:~$ ping 10.1.4.10 PING 10.1.4.10 (10.1.4.10) 56(84) bytes of data. 64 bytes from 10.1.4.10: icmp_seq=1 ttl=63 time=0.948 ms 64 bytes from 10.1.4.10: icmp_seq=2 ttl=63 time=1.83 ms 64 bytes from 10.1.4.10: icmp_seq=3 ttl=63 time=1.72 ms ^C --- 10.1.4.10 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2004ms rtt min/avg/max/mdev = 0.948/1.502/1.832/0.395 ms vagrant@site1server1:~$ Helpful References I couldn\u0026rsquo;t have created this post without the following helpful sites.\nVirtual Routing and Forwarding in Linux ","permalink":"https://briantsaunders.github.io/posts/2019/05/creating-vrfs-in-linux-with-python/","summary":"\u003cp\u003eIn this post I\u0026rsquo;m going to talk about how to create, edit, and delete VRFs in linux with python.  To follow along I have created a vagrant environment and example python script in \u003ca href=\"https://github.com/briantsaunders/linux-vrf-example-python-script\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"Creating VRFs in Linux With Python"},{"content":"In this post I\u0026rsquo;m going to talk about how to create a point to point VXLAN tunnel between two linux hosts with Python. To follow along I have created a vagrant environment and example python script in github.\nHere\u0026rsquo;s our environment and we\u0026rsquo;re going to form a VXLAN tunnel between the site1router and site2router.\nThis will allow the hosts connected to eth2 talk to each other as if they are directly connected. In order to form the VXLAN tunnel overlay the underlay needs to be setup and routing needs to be operational. The interfaces that will be used as the VXLAN Tunnel Endpoint (VTEP) between the two linux hosts need to be able to reach each other. Our site routers are eBGP peering with an isp router and directly connected interfaces are being redistributed into the underlay.\nPrerequisites On the linux host that will be forming the VXLAN tunnel you need to make sure you have the following installed.\nbridge utils pyroute2 Pyroute2 is the python package that is going to allow for the creation of the VXLAN tunnels. It\u0026rsquo;s very useful for interacting with the linux network stack with python.\nOn the interface that you are going to bridge with the VXLAN interface you need to ensure that promiscuous mode is enabled within the hypervisor. In our vagrant environment this is enabled for you.\nVXLAN Tunnel CLI Commands Before we show how to set this up within python lets review the CLI commands that you would enter if you wanted to manually configure. We\u0026rsquo;re going to be using our vagrant environment as the example for the commands to use.\nsite1router Create\nsudo ip link set eth2 up sudo ip link add vxlan100 type vxlan id 100 local 192.168.0.2 remote 192.168.0.5 nolearning sudo ip link set vxlan100 up sudo brctl addbr br100 sudo brctl addif br100 vxlan100 sudo brctl addif br100 eth2 sudo brctl stp br100 off sudo ip link set br100 up Delete\nsudo ip link delete vxlan100 sudo ip link delete br100 site2router Create\nsudo ip link set eth2 up sudo ip link add vxlan100 type vxlan id 100 local 192.168.0.5 remote 192.168.0.2 nolearning sudo ip link set vxlan100 up sudo brctl addbr br100 sudo brctl addif br100 vxlan100 sudo brctl addif br100 eth2 sudo brctl stp br100 off sudo ip link set br100 up Delete\nsudo ip link delete vxlan100 sudo ip link delete br100 VXLAN Tunnel in Python When working with the IPDB module within pyroute2 you need to commit your changes. You can leverage a context manager to automatically commit the code at the end. In this example we are going to manually commit our changes after each change. This code is essentially the equivalent of the CLI commands referenced above.\nsite1router Create\nfrom pyroute2 import IPDB ipdb = IPDB() ipdb.interfaces[\u0026#34;eth2\u0026#34;].up() ipdb.interfaces[\u0026#34;eth2\u0026#34;].commit() ipdb.create( kind=\u0026#34;vxlan\u0026#34;, ifname=f\u0026#34;vxlan100\u0026#34;, vxlan_id=100, vxlan_learning=False, vxlan_local=\u0026#34;192.168.0.2\u0026#34;, vxlan_group=\u0026#34;192.168.0.5\u0026#34; ) ipdb.interfaces[\u0026#34;vxlan100\u0026#34;].commit() ipdb.interfaces[\u0026#34;vxlan100\u0026#34;].up() ipdb.interfaces[\u0026#34;vxlan100\u0026#34;].commit() ipdb.create(kind=\u0026#34;bridge\u0026#34;, ifname=\u0026#34;br100\u0026#34;) ipdb.interfaces[\u0026#34;br100\u0026#34;].add_port(ipdb.interfaces[\u0026#34;vxlan100\u0026#34;].index) ipdb.interfaces[\u0026#34;br100\u0026#34;].add_port(ipdb.interfaces[\u0026#34;eth2\u0026#34;].index) ipdb.interfaces[\u0026#34;br100\u0026#34;].up() ipdb.interfaces[\u0026#34;br100\u0026#34;].commit() Delete\nfrom pyroute2 import IPDB ipdb = IPDB() ipdb.interfaces[\u0026#34;vlan100\u0026#34;].remove() ipdb.interfaces[\u0026#34;br100\u0026#34;].remove() ipdb.commit() site2router Create\nfrom pyroute2 import IPDB ipdb = IPDB() ipdb.interfaces[\u0026#34;eth2\u0026#34;].up() ipdb.interfaces[\u0026#34;eth2\u0026#34;].commit() ipdb.create( kind=\u0026#34;vxlan\u0026#34;, ifname=f\u0026#34;vxlan100\u0026#34;, vxlan_id=100, vxlan_learning=False, vxlan_local=\u0026#34;192.168.0.5\u0026#34;, vxlan_group=\u0026#34;192.168.0.2\u0026#34; ) ipdb.interfaces[\u0026#34;vxlan100\u0026#34;].commit() ipdb.interfaces[\u0026#34;vxlan100\u0026#34;].up() ipdb.interfaces[\u0026#34;vxlan100\u0026#34;].commit() ipdb.create(kind=\u0026#34;bridge\u0026#34;, ifname=\u0026#34;br100\u0026#34;) ipdb.interfaces[\u0026#34;br100\u0026#34;].add_port(ipdb.interfaces[\u0026#34;vxlan100\u0026#34;].index) ipdb.interfaces[\u0026#34;br100\u0026#34;].add_port(ipdb.interfaces[\u0026#34;eth2\u0026#34;].index) ipdb.interfaces[\u0026#34;br100\u0026#34;].up() ipdb.interfaces[\u0026#34;br100\u0026#34;].commit() Delete\nfrom pyroute2 import IPDB ipdb = IPDB() ipdb.interfaces[\u0026#34;vlan100\u0026#34;].remove() ipdb.interfaces[\u0026#34;br100\u0026#34;].remove() ipdb.commit() Validating VXLAN Tunnel Ping site1server to site2server\nvagrant@site1server:~$ ping 172.16.0.11 PING 172.16.0.11 (172.16.0.11) 56(84) bytes of data. 64 bytes from 172.16.0.11: icmp_seq=1 ttl=64 time=1.24 ms ^C --- 172.16.0.11 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 1.246/1.246/1.246/0.000 ms vagrant@site1server:~$ PCAP site1router eth2 interface site1router vxlan100 interface site1router br100 interface site1router eth1 interface Helpful References I couldn\u0026rsquo;t have created this post without the following helpful sites.\nVincent Bernat Linux \u0026amp; VXLAN Joe Julian How To Configure Linux VXLANs ","permalink":"https://briantsaunders.github.io/posts/2019/05/creating-vxlan-tunnel-in-linux-with-python/","summary":"\u003cp\u003eIn this post I\u0026rsquo;m going to talk about how to create a point to point VXLAN tunnel between two linux hosts with Python.  To follow along I have created a vagrant environment and example python script in \u003ca href=\"https://github.com/briantsaunders/linux-vxlan-tunnel-example-python-script\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"Creating a VXLAN Tunnel in Linux with Python"}]